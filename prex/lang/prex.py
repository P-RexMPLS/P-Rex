# This file was generated by SableCC (http://www.sablecc.org/). 

from io import IOBase

def caller(n=1):
    import inspect
    return inspect.getouterframes(inspect.currentframe())[n][3]
    
def abstract():
    raise NotImplementedError(caller() + ' must be implemented in subclass')

class Stack(list):
    def push(self, value):
        self.append(value)
    
    def peek(self):
        return self[len(self)-1]
    
    def empty(self):
        return len(self) == 0
            
class PushbackReader(object):
    def __init__(self, reader):
        self.__reader = reader
        self.__stack = Stack()

    def peek (self):
        if (len(self.__stack) > 0 ): 
            result = self.__stack.peek()
        else:
            result = self.__reader.read(1)
            self.__reader.seek(-1, 1) # go back to the previous position
        return result

    def read (self):
        if ( len(self.__stack) > 0 ):
            return self.__stack.pop()
        return self.__reader.read(1)

    def unread (self, c):
        self.__stack.append(c)

class StringBuffer(object):
  def __init__(self, obj=None):
      self.buffer = [] 
      if not(obj == None):
          if isinstance(obj, str):
              self.buffer.extend(list(obj))
          else:
              self.buffer.extend(list(str(obj)))
      
  def append(self, obj):
      if isinstance(obj, str):
          self.buffer.extend(list(obj))
      else:
          self.buffer.extend(list(str(obj)))
      
  def charAt(self, index):
      return self.buffer[index]
  
  def __len__(self):
      return len(self.buffer)
  
  def __eq__(self, other):
      if type(self) != type(other):
          return False
      else:
          return (self.buffer == other.buffer)
  
  def __ne__(self, other):
      if type(self) != type(other):
          return True
      else:
          return (self.buffer != other.buffer)
        
  def clear(self):
      del self.buffer[0:len(self.buffer)]
  
  def __str__(self):
      return ''.join(self.buffer)
      
  def __repr__(self):
      return "'" + self.__str__() + "'"
  
  def substring(self, start, finish):
      return ''.join(self.buffer[start:finish])
      
  def __getitem__(self, index):
      return self.buffer[index]
      
  def __setitem__(self, index, c):
      if not(isinstance(c, str)):
          raise RuntimeError("Only single characters can be assigned")
      if not(len(c) == 1):
          raise RuntimeError("Only single characters can be assigned")
      self.buffer[index] = c
  
  def __iter__(self):
      return self.buffer
  
  def __getslice__(self, start, finish):
      return self.substring(start, finish)
      
  def reverse(self):
      self.buffer.reverse()
    
  def __contains__(self, c):
      if not(isinstance(c, str)):
          raise RuntimeError("Only single characters can be assigned")
      if not(len(c) == 1):
          raise RuntimeError("Only single characters can be assigned")
      return self.buffer.__contains__(c)
      
  def contains(self, c):
      self.__contains__(c)



############################# nodes.py ############################################## 

class Node(object):
    def __init__(self):
        if self.__class__ is Node:
            raise TypeError("Node class can not be instantiated.")
        self.parent = None

    def clone(self):
        abstract()
        
    def getParent(self):
        return self.parent

    def setParent(self, parent):
        self.parent = parent

    def removeChild(self, child):
        abstract()
        
    def replaceChild(self, oldChild, newChild):
        abstract()

    def replaceBy(self, node):
        if self.parent != None:
            self.parent.replaceChild(self, node)

    def toString(self, other):
        if isinstance(other, list):
            sb = StringBuffer()

            for node in other:
                s.append(node)

            return str(sb)
        
        if (other != None):
            return str(other)

        return ''
        
    def cloneNode(self, node):
        if node != None:
            return node.clone()

        return None

    def cloneList(self, lst):
        clone = list()

        for node in lst:
            clone.append(node.clone())

        return clone

    def apply(self, analysis, *args, **kwargs):
        abstract()

class Token(Node):
    def __init__(self):
        super(Token, self).__init__()
        self.text = None
        self.line = 0
        self.pos = 0

    def getText(self):
        return self.text

    def setText(self, text):
        self.text = text

    def getLine(self):
        return self.line

    def setLine(self, line):
        self.line = line

    def getPos(self):
        return self.pos

    def setPos(self, pos):
        self.pos = pos

    def __str__(self):
        return self.text + " "
    
    def removeChild(self, child):
        pass
      
    def replaceChild(self, oldChild,  newChild):
        pass
      

class TChevLeft(Token):
    TokenIndex = 0
    
    def __init__(self, line=0, pos=0):
        super(TChevLeft, self).__init__()
        super(TChevLeft, self).setText("<")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TChevLeft(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis, *args, **kwargs):
        return analysis.caseTChevLeft(self, *args, **kwargs)

    def setText(self, text):
        raise RuntimeError("Cannot change TChevLeft text.")


class TChevRight(Token):
    TokenIndex = 1
    
    def __init__(self, line=0, pos=0):
        super(TChevRight, self).__init__()
        super(TChevRight, self).setText(">")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TChevRight(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis, *args, **kwargs):
        return analysis.caseTChevRight(self, *args, **kwargs)

    def setText(self, text):
        raise RuntimeError("Cannot change TChevRight text.")


class TParenLeft(Token):
    TokenIndex = 2
    
    def __init__(self, line=0, pos=0):
        super(TParenLeft, self).__init__()
        super(TParenLeft, self).setText("(")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TParenLeft(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis, *args, **kwargs):
        return analysis.caseTParenLeft(self, *args, **kwargs)

    def setText(self, text):
        raise RuntimeError("Cannot change TParenLeft text.")


class TParenRight(Token):
    TokenIndex = 3
    
    def __init__(self, line=0, pos=0):
        super(TParenRight, self).__init__()
        super(TParenRight, self).setText(")")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TParenRight(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis, *args, **kwargs):
        return analysis.caseTParenRight(self, *args, **kwargs)

    def setText(self, text):
        raise RuntimeError("Cannot change TParenRight text.")


class TSqLeft(Token):
    TokenIndex = 4
    
    def __init__(self, line=0, pos=0):
        super(TSqLeft, self).__init__()
        super(TSqLeft, self).setText("[")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TSqLeft(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis, *args, **kwargs):
        return analysis.caseTSqLeft(self, *args, **kwargs)

    def setText(self, text):
        raise RuntimeError("Cannot change TSqLeft text.")


class TSqRight(Token):
    TokenIndex = 5
    
    def __init__(self, line=0, pos=0):
        super(TSqRight, self).__init__()
        super(TSqRight, self).setText("]")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TSqRight(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis, *args, **kwargs):
        return analysis.caseTSqRight(self, *args, **kwargs)

    def setText(self, text):
        raise RuntimeError("Cannot change TSqRight text.")


class TBracLeft(Token):
    TokenIndex = 6
    
    def __init__(self, line=0, pos=0):
        super(TBracLeft, self).__init__()
        super(TBracLeft, self).setText("{")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TBracLeft(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis, *args, **kwargs):
        return analysis.caseTBracLeft(self, *args, **kwargs)

    def setText(self, text):
        raise RuntimeError("Cannot change TBracLeft text.")


class TBracRight(Token):
    TokenIndex = 7
    
    def __init__(self, line=0, pos=0):
        super(TBracRight, self).__init__()
        super(TBracRight, self).setText("}")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TBracRight(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis, *args, **kwargs):
        return analysis.caseTBracRight(self, *args, **kwargs)

    def setText(self, text):
        raise RuntimeError("Cannot change TBracRight text.")


class TPipe(Token):
    TokenIndex = 8
    
    def __init__(self, line=0, pos=0):
        super(TPipe, self).__init__()
        super(TPipe, self).setText("|")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TPipe(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis, *args, **kwargs):
        return analysis.caseTPipe(self, *args, **kwargs)

    def setText(self, text):
        raise RuntimeError("Cannot change TPipe text.")


class TStar(Token):
    TokenIndex = 9
    
    def __init__(self, line=0, pos=0):
        super(TStar, self).__init__()
        super(TStar, self).setText("*")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TStar(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis, *args, **kwargs):
        return analysis.caseTStar(self, *args, **kwargs)

    def setText(self, text):
        raise RuntimeError("Cannot change TStar text.")


class TPlus(Token):
    TokenIndex = 10
    
    def __init__(self, line=0, pos=0):
        super(TPlus, self).__init__()
        super(TPlus, self).setText("+")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TPlus(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis, *args, **kwargs):
        return analysis.caseTPlus(self, *args, **kwargs)

    def setText(self, text):
        raise RuntimeError("Cannot change TPlus text.")


class TComma(Token):
    TokenIndex = 11
    
    def __init__(self, line=0, pos=0):
        super(TComma, self).__init__()
        super(TComma, self).setText(",")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TComma(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis, *args, **kwargs):
        return analysis.caseTComma(self, *args, **kwargs)

    def setText(self, text):
        raise RuntimeError("Cannot change TComma text.")


class THat(Token):
    TokenIndex = 12
    
    def __init__(self, line=0, pos=0):
        super(THat, self).__init__()
        super(THat, self).setText("^")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return THat(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis, *args, **kwargs):
        return analysis.caseTHat(self, *args, **kwargs)

    def setText(self, text):
        raise RuntimeError("Cannot change THat text.")


class TDot(Token):
    TokenIndex = 13
    
    def __init__(self, line=0, pos=0):
        super(TDot, self).__init__()
        super(TDot, self).setText(".")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TDot(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis, *args, **kwargs):
        return analysis.caseTDot(self, *args, **kwargs)

    def setText(self, text):
        raise RuntimeError("Cannot change TDot text.")


class TQuestionMark(Token):
    TokenIndex = 14
    
    def __init__(self, line=0, pos=0):
        super(TQuestionMark, self).__init__()
        super(TQuestionMark, self).setText("?")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TQuestionMark(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis, *args, **kwargs):
        return analysis.caseTQuestionMark(self, *args, **kwargs)

    def setText(self, text):
        raise RuntimeError("Cannot change TQuestionMark text.")


class TBlank(Token):
    TokenIndex = -1
        
    def __init__(self, text, line=0, pos=0):
        super(TBlank, self).__init__()    
        self.setText(text)
        self.setLine(line)
        self.setPos(pos)
        
    def clone(self):
      return TBlank(self.getText(), self.getLine(), self.getPos())

    def apply(self, analysis, *args, **kwargs):
       return analysis.caseTBlank(self, *args, **kwargs)
      
class TWord(Token):
    TokenIndex = 15
    
    def __init__(self, text, line=0, pos=0):
        super(TWord, self).__init__()    
        self.setText(text)
        self.setLine(line)
        self.setPos(pos)
        
    def clone(self):
      return TWord(self.getText(), self.getLine(), self.getPos())

    def apply(self, analysis, *args, **kwargs):
       return analysis.caseTWord(self, *args, **kwargs)
      

class EOF(Token):
    TokenIndex = 16

    def __init__(self, line=0, pos=0):
        super(EOF, self).__init__()    
        self.setText("")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return EOF(self.getLine(), self.getPos())

    def apply(self, analysis, *args, **kwargs):
        return analysis.caseEOF(self, *args, **kwargs)


class AQuery(Node):
    def __init__ (self, _constructing_=None,_network_=None,_destructing_=None):
        super().__init__()
        self._constructing_ = None
        self._network_ = None
        self._destructing_ = None
        if _constructing_ != None:
            self.setConstructing(_constructing_)
        if _network_ != None:
            self.setNetwork(_network_)
        if _destructing_ != None:
            self.setDestructing(_destructing_)

    def clone(self):
        return AQuery(self.cloneNode(self._constructing_),self.cloneNode(self._network_),self.cloneNode(self._destructing_))

    def apply(self, analysis, *args, **kwargs):
        return analysis.caseAQuery(self, *args, **kwargs)

    def getConstructing (self):
        return self._constructing_

    def setConstructing(self, node):
        if self._constructing_ != None:
            self._constructing_.setParent(None)

        if node != None:
            if node.getParent() != None:
                node.getParent().removeChild(node)

            node.setParent(self)

        self._constructing_ = node
    def getNetwork (self):
        return self._network_

    def setNetwork(self, node):
        if self._network_ != None:
            self._network_.setParent(None)

        if node != None:
            if node.getParent() != None:
                node.getParent().removeChild(node)

            node.setParent(self)

        self._network_ = node
    def getDestructing (self):
        return self._destructing_

    def setDestructing(self, node):
        if self._destructing_ != None:
            self._destructing_.setParent(None)

        if node != None:
            if node.getParent() != None:
                node.getParent().removeChild(node)

            node.setParent(self)

        self._destructing_ = node

    def __str__(self):
        return '' + self.toString(self._constructing_)+ self.toString(self._network_)+ self.toString(self._destructing_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if self._constructing_ == child:
            self._constructing_ = None
            return
        if self._network_ == child:
            self._network_ = None
            return
        if self._destructing_ == child:
            self._destructing_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if self._constructing_ == oldChild:
            self.setConstructing(newChild)
            return
        if self._network_ == oldChild:
            self.setNetwork(newChild)
            return
        if self._destructing_ == oldChild:
            self.setDestructing(newChild)
            return

class ASimpleSymbol(Node):
    def __init__ (self, _symbol_type_=None):
        super().__init__()
        self._symbol_type_ = None
        if _symbol_type_ != None:
            self.setSymbolType(_symbol_type_)

    def clone(self):
        return ASimpleSymbol(self.cloneNode(self._symbol_type_))

    def apply(self, analysis, *args, **kwargs):
        return analysis.caseASimpleSymbol(self, *args, **kwargs)

    def getSymbolType (self):
        return self._symbol_type_

    def setSymbolType(self, node):
        if self._symbol_type_ != None:
            self._symbol_type_.setParent(None)

        if node != None:
            if node.getParent() != None:
                node.getParent().removeChild(node)

            node.setParent(self)

        self._symbol_type_ = node

    def __str__(self):
        return '' + self.toString(self._symbol_type_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if self._symbol_type_ == child:
            self._symbol_type_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if self._symbol_type_ == oldChild:
            self.setSymbolType(newChild)
            return

class ATupleSymbol(Node):
    def __init__ (self, _router_=None,_interface_=None,_failures_=None,_ops_=None):
        super().__init__()
        self._router_ = None
        self._interface_ = None
        self._failures_ = None
        self._ops_ = None
        if _router_ != None:
            self.setRouter(_router_)
        if _interface_ != None:
            self.setInterface(_interface_)
        if _failures_ != None:
            self.setFailures(_failures_)
        if _ops_ != None:
            self.setOps(_ops_)

    def clone(self):
        return ATupleSymbol(self.cloneNode(self._router_),self.cloneNode(self._interface_),self.cloneNode(self._failures_),self.cloneNode(self._ops_))

    def apply(self, analysis, *args, **kwargs):
        return analysis.caseATupleSymbol(self, *args, **kwargs)

    def getRouter (self):
        return self._router_

    def setRouter(self, node):
        if self._router_ != None:
            self._router_.setParent(None)

        if node != None:
            if node.getParent() != None:
                node.getParent().removeChild(node)

            node.setParent(self)

        self._router_ = node
    def getInterface (self):
        return self._interface_

    def setInterface(self, node):
        if self._interface_ != None:
            self._interface_.setParent(None)

        if node != None:
            if node.getParent() != None:
                node.getParent().removeChild(node)

            node.setParent(self)

        self._interface_ = node
    def getFailures (self):
        return self._failures_

    def setFailures(self, node):
        if self._failures_ != None:
            self._failures_.setParent(None)

        if node != None:
            if node.getParent() != None:
                node.getParent().removeChild(node)

            node.setParent(self)

        self._failures_ = node
    def getOps (self):
        return self._ops_

    def setOps(self, node):
        if self._ops_ != None:
            self._ops_.setParent(None)

        if node != None:
            if node.getParent() != None:
                node.getParent().removeChild(node)

            node.setParent(self)

        self._ops_ = node

    def __str__(self):
        return '' + self.toString(self._router_)+ self.toString(self._interface_)+ self.toString(self._failures_)+ self.toString(self._ops_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if self._router_ == child:
            self._router_ = None
            return
        if self._interface_ == child:
            self._interface_ = None
            return
        if self._failures_ == child:
            self._failures_ = None
            return
        if self._ops_ == child:
            self._ops_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if self._router_ == oldChild:
            self.setRouter(newChild)
            return
        if self._interface_ == oldChild:
            self.setInterface(newChild)
            return
        if self._failures_ == oldChild:
            self.setFailures(newChild)
            return
        if self._ops_ == oldChild:
            self.setOps(newChild)
            return

class ALiteralSymbolType(Node):
    def __init__ (self, _word_=None):
        super().__init__()
        self._word_ = None
        if _word_ != None:
            self.setWord(_word_)

    def clone(self):
        return ALiteralSymbolType(self.cloneNode(self._word_))

    def apply(self, analysis, *args, **kwargs):
        return analysis.caseALiteralSymbolType(self, *args, **kwargs)

    def getWord (self):
        return self._word_

    def setWord(self, node):
        if self._word_ != None:
            self._word_.setParent(None)

        if node != None:
            if node.getParent() != None:
                node.getParent().removeChild(node)

            node.setParent(self)

        self._word_ = node

    def __str__(self):
        return '' + self.toString(self._word_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if self._word_ == child:
            self._word_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if self._word_ == oldChild:
            self.setWord(newChild)
            return

class ASimpleAtom(Node):
    def __init__ (self, _symbol_=None):
        super().__init__()
        self._symbol_ = None
        if _symbol_ != None:
            self.setSymbol(_symbol_)

    def clone(self):
        return ASimpleAtom(self.cloneNode(self._symbol_))

    def apply(self, analysis, *args, **kwargs):
        return analysis.caseASimpleAtom(self, *args, **kwargs)

    def getSymbol (self):
        return self._symbol_

    def setSymbol(self, node):
        if self._symbol_ != None:
            self._symbol_.setParent(None)

        if node != None:
            if node.getParent() != None:
                node.getParent().removeChild(node)

            node.setParent(self)

        self._symbol_ = node

    def __str__(self):
        return '' + self.toString(self._symbol_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if self._symbol_ == child:
            self._symbol_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if self._symbol_ == oldChild:
            self.setSymbol(newChild)
            return

class ASequenceAtom(Node):
    def __init__ (self, _atoms_=None):
        super().__init__()
        self._atoms_ = list()
        if _atoms_ != None:
            self._atoms_.extend(_atoms_)

    def clone(self):
        return ASequenceAtom(self.cloneList(self._atoms_))

    def apply(self, analysis, *args, **kwargs):
        return analysis.caseASequenceAtom(self, *args, **kwargs)

    def getAtoms(self):
        return self._atoms_

    def setAtoms(self, lst):
        del self._atoms_[0:len(self._atoms_)]
        self._atoms_.extend(lst)
        

    def __str__(self):
        return '' + self.toString(self._atoms_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if child in self._atoms_:
            self._atoms_.remove(child)
            return

    def replaceChild(self, oldChild, newChild):
        for i in range(self._atoms_):
            if self._atoms_[i] == oldChild:
                if newChild != None:
                    self._atoms_[i] = newChild
                    oldChild.setParent(None)
                    return

                del self._atoms_[i]
                oldChild.setParent(None)
                return

class AAnyAtom(Node):
    def __init__ (self, ):
        super().__init__()

    def clone(self):
        return AAnyAtom()

    def apply(self, analysis, *args, **kwargs):
        return analysis.caseAAnyAtom(self, *args, **kwargs)


    def __str__(self):
        return '' 
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        pass

    def replaceChild(self, oldChild, newChild):
        pass

class AAlternativeAtom(Node):
    def __init__ (self, _left_=None,_right_=None):
        super().__init__()
        self._left_ = None
        self._right_ = None
        if _left_ != None:
            self.setLeft(_left_)
        if _right_ != None:
            self.setRight(_right_)

    def clone(self):
        return AAlternativeAtom(self.cloneNode(self._left_),self.cloneNode(self._right_))

    def apply(self, analysis, *args, **kwargs):
        return analysis.caseAAlternativeAtom(self, *args, **kwargs)

    def getLeft (self):
        return self._left_

    def setLeft(self, node):
        if self._left_ != None:
            self._left_.setParent(None)

        if node != None:
            if node.getParent() != None:
                node.getParent().removeChild(node)

            node.setParent(self)

        self._left_ = node
    def getRight (self):
        return self._right_

    def setRight(self, node):
        if self._right_ != None:
            self._right_.setParent(None)

        if node != None:
            if node.getParent() != None:
                node.getParent().removeChild(node)

            node.setParent(self)

        self._right_ = node

    def __str__(self):
        return '' + self.toString(self._left_)+ self.toString(self._right_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if self._left_ == child:
            self._left_ = None
            return
        if self._right_ == child:
            self._right_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if self._left_ == oldChild:
            self.setLeft(newChild)
            return
        if self._right_ == oldChild:
            self.setRight(newChild)
            return

class AQuantifiedAtom(Node):
    def __init__ (self, _atom_=None,_quantifier_=None):
        super().__init__()
        self._atom_ = None
        self._quantifier_ = None
        if _atom_ != None:
            self.setAtom(_atom_)
        if _quantifier_ != None:
            self.setQuantifier(_quantifier_)

    def clone(self):
        return AQuantifiedAtom(self.cloneNode(self._atom_),self.cloneNode(self._quantifier_))

    def apply(self, analysis, *args, **kwargs):
        return analysis.caseAQuantifiedAtom(self, *args, **kwargs)

    def getAtom (self):
        return self._atom_

    def setAtom(self, node):
        if self._atom_ != None:
            self._atom_.setParent(None)

        if node != None:
            if node.getParent() != None:
                node.getParent().removeChild(node)

            node.setParent(self)

        self._atom_ = node
    def getQuantifier (self):
        return self._quantifier_

    def setQuantifier(self, node):
        if self._quantifier_ != None:
            self._quantifier_.setParent(None)

        if node != None:
            if node.getParent() != None:
                node.getParent().removeChild(node)

            node.setParent(self)

        self._quantifier_ = node

    def __str__(self):
        return '' + self.toString(self._atom_)+ self.toString(self._quantifier_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if self._atom_ == child:
            self._atom_ = None
            return
        if self._quantifier_ == child:
            self._quantifier_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if self._atom_ == oldChild:
            self.setAtom(newChild)
            return
        if self._quantifier_ == oldChild:
            self.setQuantifier(newChild)
            return

class ANegativeSetAtom(Node):
    def __init__ (self, _symbols_=None):
        super().__init__()
        self._symbols_ = list()
        if _symbols_ != None:
            self._symbols_.extend(_symbols_)

    def clone(self):
        return ANegativeSetAtom(self.cloneList(self._symbols_))

    def apply(self, analysis, *args, **kwargs):
        return analysis.caseANegativeSetAtom(self, *args, **kwargs)

    def getSymbols(self):
        return self._symbols_

    def setSymbols(self, lst):
        del self._symbols_[0:len(self._symbols_)]
        self._symbols_.extend(lst)
        

    def __str__(self):
        return '' + self.toString(self._symbols_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if child in self._symbols_:
            self._symbols_.remove(child)
            return

    def replaceChild(self, oldChild, newChild):
        for i in range(self._symbols_):
            if self._symbols_[i] == oldChild:
                if newChild != None:
                    self._symbols_[i] = newChild
                    oldChild.setParent(None)
                    return

                del self._symbols_[i]
                oldChild.setParent(None)
                return

class APositiveSetAtom(Node):
    def __init__ (self, _symbols_=None):
        super().__init__()
        self._symbols_ = list()
        if _symbols_ != None:
            self._symbols_.extend(_symbols_)

    def clone(self):
        return APositiveSetAtom(self.cloneList(self._symbols_))

    def apply(self, analysis, *args, **kwargs):
        return analysis.caseAPositiveSetAtom(self, *args, **kwargs)

    def getSymbols(self):
        return self._symbols_

    def setSymbols(self, lst):
        del self._symbols_[0:len(self._symbols_)]
        self._symbols_.extend(lst)
        

    def __str__(self):
        return '' + self.toString(self._symbols_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if child in self._symbols_:
            self._symbols_.remove(child)
            return

    def replaceChild(self, oldChild, newChild):
        for i in range(self._symbols_):
            if self._symbols_[i] == oldChild:
                if newChild != None:
                    self._symbols_[i] = newChild
                    oldChild.setParent(None)
                    return

                del self._symbols_[i]
                oldChild.setParent(None)
                return

class AZeroOrMoreQuantifier(Node):
    def __init__ (self, ):
        super().__init__()

    def clone(self):
        return AZeroOrMoreQuantifier()

    def apply(self, analysis, *args, **kwargs):
        return analysis.caseAZeroOrMoreQuantifier(self, *args, **kwargs)


    def __str__(self):
        return '' 
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        pass

    def replaceChild(self, oldChild, newChild):
        pass

class AOneOrMoreQuantifier(Node):
    def __init__ (self, ):
        super().__init__()

    def clone(self):
        return AOneOrMoreQuantifier()

    def apply(self, analysis, *args, **kwargs):
        return analysis.caseAOneOrMoreQuantifier(self, *args, **kwargs)


    def __str__(self):
        return '' 
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        pass

    def replaceChild(self, oldChild, newChild):
        pass

class AZeroOrOneQuantifier(Node):
    def __init__ (self, ):
        super().__init__()

    def clone(self):
        return AZeroOrOneQuantifier()

    def apply(self, analysis, *args, **kwargs):
        return analysis.caseAZeroOrOneQuantifier(self, *args, **kwargs)


    def __str__(self):
        return '' 
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        pass

    def replaceChild(self, oldChild, newChild):
        pass


class Start(Node):
    def __init__(self, _base_=None, _eof_=None):
        super().__init__()
        self._base_ = None
        self._eof_ = None
        self.setPQuery(_base_)
        self.setEOF(_eof_)

    def clone(self):
        return Start(self.cloneNode(self._base_), self.cloneNode(self._eof_))

    def apply(self, analysis, *args, **kwargs):
        return analysis.caseStart(self, *args, **kwargs)

    def getPQuery(self):
        return self._base_
        
    def setPQuery(self, node):
        if self._base_ != None:
            self._base_.setParent(None)

        if node != None:
            if node.getParent() != None:
                node.getParent().removeChild(node)

            node.setParent(self)

        self._base_ = node

    def getEOF(self):
        return self._eof_
        
    def setEOF(self, node):
        if self._eof_ != None:
            self._eof_.setParent(None)

        if node != None:
            if node.getParent() != None:
                node.getParent().removeChild(node)

            node.setParent(self)

        self._eof_ = node

    def removeChild(self, child):
        if self._base_ == child:
            self._base_ = None
            return

        if self._eof_ == child:
            self._eof_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if self._base_ == oldChild:
            self.setPQuery(newChild)
            return

        if self._eof_ == oldChild:
            self.setEOF(newChild)
            return

    def __str__(self):
        return '' + self.toString(self._base_) + self.toString(self._eof_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
     

############################# analysis.py #############################################

class Analysis(object):
    def __init__(self):
        self._in_ = None
        self._out_ = None

    def getIn(self, node):
        if self._in_ == None:
            return None
            
        if node in self._in_:
            return self._in_[node]
        else:
            return None

    def setIn(self, node, _in_):
        if self._in_ == None:
            self._in_ = {}

        if _in_ != None:
            self._in_[node] = _in_
        else:
            if node in self._in_:
                del self._in_[node]

    def getOut(self, node):
        if self._out_ == None:
            return None
            
        if node in self._out_:
            return self._out_[node]
        else:
            return None

    def setOut(self, node, _out_):
        if self._out_ == None:
            self._out_ = {}

        if _out_ != None:
            self._out_[node] = _out_
        else:
            if node in self._out_:
                del self._out_[node]

    def caseStart(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)

    def caseAQuery(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseASimpleSymbol(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseATupleSymbol(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseALiteralSymbolType(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseASimpleAtom(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseASequenceAtom(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseAAnyAtom(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseAAlternativeAtom(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseAQuantifiedAtom(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseANegativeSetAtom(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseAPositiveSetAtom(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseAZeroOrMoreQuantifier(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseAOneOrMoreQuantifier(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseAZeroOrOneQuantifier(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        

    def caseTBlank(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseTChevLeft(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseTChevRight(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseTParenLeft(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseTParenRight(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseTSqLeft(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseTSqRight(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseTBracLeft(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseTBracRight(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseTPipe(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseTStar(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseTPlus(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseTComma(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseTHat(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseTDot(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseTQuestionMark(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseTWord(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)
        
    def caseEOF(self, node, *args, **kwargs):
        self.defaultCase(node, *args, **kwargs)

    def defaultCase(self, node, *args, **kwargs):
        pass


class DepthFirstAdapter(Analysis):
    def inStart(self, node):
        self.defaultIn(node)

    def outStart(self, node):
        self.defaultOut(node)

    def defaultIn(self, node):
        pass

    def defaultOut(self, node):
        pass

    def caseStart(self, node, *args, **kwargs):
        self.inStart(node)
        node.getPQuery().apply(self, *args, **kwargs)
        node.getEOF().apply(self, *args, **kwargs);
        self.outStart(node)

    def inAQuery(self, node):
        self.defaultIn(node)

    def outAQuery(self, node):
        self.defaultOut(node)

    def caseAQuery(self, node, *args, **kwargs):
        self.inAQuery(node)
        if not(node.getConstructing() == None):
            node.getConstructing().apply(self, *args, **kwargs)
        if not(node.getNetwork() == None):
            node.getNetwork().apply(self, *args, **kwargs)
        if not(node.getDestructing() == None):
            node.getDestructing().apply(self, *args, **kwargs)
        self.outAQuery(node)
        
    def inASimpleSymbol(self, node):
        self.defaultIn(node)

    def outASimpleSymbol(self, node):
        self.defaultOut(node)

    def caseASimpleSymbol(self, node, *args, **kwargs):
        self.inASimpleSymbol(node)
        if not(node.getSymbolType() == None):
            node.getSymbolType().apply(self, *args, **kwargs)
        self.outASimpleSymbol(node)
        
    def inATupleSymbol(self, node):
        self.defaultIn(node)

    def outATupleSymbol(self, node):
        self.defaultOut(node)

    def caseATupleSymbol(self, node, *args, **kwargs):
        self.inATupleSymbol(node)
        if not(node.getRouter() == None):
            node.getRouter().apply(self, *args, **kwargs)
        if not(node.getInterface() == None):
            node.getInterface().apply(self, *args, **kwargs)
        if not(node.getFailures() == None):
            node.getFailures().apply(self, *args, **kwargs)
        if not(node.getOps() == None):
            node.getOps().apply(self, *args, **kwargs)
        self.outATupleSymbol(node)
        
    def inALiteralSymbolType(self, node):
        self.defaultIn(node)

    def outALiteralSymbolType(self, node):
        self.defaultOut(node)

    def caseALiteralSymbolType(self, node, *args, **kwargs):
        self.inALiteralSymbolType(node)
        if not(node.getWord() == None):
            node.getWord().apply(self, *args, **kwargs)
        self.outALiteralSymbolType(node)
        
    def inASimpleAtom(self, node):
        self.defaultIn(node)

    def outASimpleAtom(self, node):
        self.defaultOut(node)

    def caseASimpleAtom(self, node, *args, **kwargs):
        self.inASimpleAtom(node)
        if not(node.getSymbol() == None):
            node.getSymbol().apply(self, *args, **kwargs)
        self.outASimpleAtom(node)
        
    def inASequenceAtom(self, node):
        self.defaultIn(node)

    def outASequenceAtom(self, node):
        self.defaultOut(node)

    def caseASequenceAtom(self, node, *args, **kwargs):
        self.inASequenceAtom(node)
        temp = node.getAtoms()
        for item in temp:
            item.apply(self, *args, **kwargs)
        self.outASequenceAtom(node)
        
    def inAAnyAtom(self, node):
        self.defaultIn(node)

    def outAAnyAtom(self, node):
        self.defaultOut(node)

    def caseAAnyAtom(self, node, *args, **kwargs):
        self.inAAnyAtom(node)
        self.outAAnyAtom(node)
        
    def inAAlternativeAtom(self, node):
        self.defaultIn(node)

    def outAAlternativeAtom(self, node):
        self.defaultOut(node)

    def caseAAlternativeAtom(self, node, *args, **kwargs):
        self.inAAlternativeAtom(node)
        if not(node.getLeft() == None):
            node.getLeft().apply(self, *args, **kwargs)
        if not(node.getRight() == None):
            node.getRight().apply(self, *args, **kwargs)
        self.outAAlternativeAtom(node)
        
    def inAQuantifiedAtom(self, node):
        self.defaultIn(node)

    def outAQuantifiedAtom(self, node):
        self.defaultOut(node)

    def caseAQuantifiedAtom(self, node, *args, **kwargs):
        self.inAQuantifiedAtom(node)
        if not(node.getAtom() == None):
            node.getAtom().apply(self, *args, **kwargs)
        if not(node.getQuantifier() == None):
            node.getQuantifier().apply(self, *args, **kwargs)
        self.outAQuantifiedAtom(node)
        
    def inANegativeSetAtom(self, node):
        self.defaultIn(node)

    def outANegativeSetAtom(self, node):
        self.defaultOut(node)

    def caseANegativeSetAtom(self, node, *args, **kwargs):
        self.inANegativeSetAtom(node)
        temp = node.getSymbols()
        for item in temp:
            item.apply(self, *args, **kwargs)
        self.outANegativeSetAtom(node)
        
    def inAPositiveSetAtom(self, node):
        self.defaultIn(node)

    def outAPositiveSetAtom(self, node):
        self.defaultOut(node)

    def caseAPositiveSetAtom(self, node, *args, **kwargs):
        self.inAPositiveSetAtom(node)
        temp = node.getSymbols()
        for item in temp:
            item.apply(self, *args, **kwargs)
        self.outAPositiveSetAtom(node)
        
    def inAZeroOrMoreQuantifier(self, node):
        self.defaultIn(node)

    def outAZeroOrMoreQuantifier(self, node):
        self.defaultOut(node)

    def caseAZeroOrMoreQuantifier(self, node, *args, **kwargs):
        self.inAZeroOrMoreQuantifier(node)
        self.outAZeroOrMoreQuantifier(node)
        
    def inAOneOrMoreQuantifier(self, node):
        self.defaultIn(node)

    def outAOneOrMoreQuantifier(self, node):
        self.defaultOut(node)

    def caseAOneOrMoreQuantifier(self, node, *args, **kwargs):
        self.inAOneOrMoreQuantifier(node)
        self.outAOneOrMoreQuantifier(node)
        
    def inAZeroOrOneQuantifier(self, node):
        self.defaultIn(node)

    def outAZeroOrOneQuantifier(self, node):
        self.defaultOut(node)

    def caseAZeroOrOneQuantifier(self, node, *args, **kwargs):
        self.inAZeroOrOneQuantifier(node)
        self.outAZeroOrOneQuantifier(node)
        


class ReversedDepthFirstAdapter(Analysis):
    def inStart(self, node):
        self.defaultIn(node)

    def outStart(self, node):
        self.defaultOut(node)

    def defaultIn(self, node):
        pass

    def defaultOut(self, node):
        pass

    def caseStart(self, node, *args, **kwargs):
        self.inStart(node)
        node.getEOF().apply(self, *args, **kwargs)
        node.getPQuery().apply(self, *args, **kwargs)
        self.outStart(node)

    def inAQuery(self, node):
        self.defaultIn(node)

    def outAQuery(self, node):
        self.defaultOut(node)

    def caseAQuery(self, node, *args, **kwargs):
        self.inAQuery(node)
        if (node.getDestructing() != None):
            node.getDestructing().apply(self, *args, **kwargs)
        if (node.getNetwork() != None):
            node.getNetwork().apply(self, *args, **kwargs)
        if (node.getConstructing() != None):
            node.getConstructing().apply(self, *args, **kwargs)
        self.outAQuery(node)
        
    def inASimpleSymbol(self, node):
        self.defaultIn(node)

    def outASimpleSymbol(self, node):
        self.defaultOut(node)

    def caseASimpleSymbol(self, node, *args, **kwargs):
        self.inASimpleSymbol(node)
        if (node.getSymbolType() != None):
            node.getSymbolType().apply(self, *args, **kwargs)
        self.outASimpleSymbol(node)
        
    def inATupleSymbol(self, node):
        self.defaultIn(node)

    def outATupleSymbol(self, node):
        self.defaultOut(node)

    def caseATupleSymbol(self, node, *args, **kwargs):
        self.inATupleSymbol(node)
        if (node.getOps() != None):
            node.getOps().apply(self, *args, **kwargs)
        if (node.getFailures() != None):
            node.getFailures().apply(self, *args, **kwargs)
        if (node.getInterface() != None):
            node.getInterface().apply(self, *args, **kwargs)
        if (node.getRouter() != None):
            node.getRouter().apply(self, *args, **kwargs)
        self.outATupleSymbol(node)
        
    def inALiteralSymbolType(self, node):
        self.defaultIn(node)

    def outALiteralSymbolType(self, node):
        self.defaultOut(node)

    def caseALiteralSymbolType(self, node, *args, **kwargs):
        self.inALiteralSymbolType(node)
        if (node.getWord() != None):
            node.getWord().apply(self, *args, **kwargs)
        self.outALiteralSymbolType(node)
        
    def inASimpleAtom(self, node):
        self.defaultIn(node)

    def outASimpleAtom(self, node):
        self.defaultOut(node)

    def caseASimpleAtom(self, node, *args, **kwargs):
        self.inASimpleAtom(node)
        if (node.getSymbol() != None):
            node.getSymbol().apply(self, *args, **kwargs)
        self.outASimpleAtom(node)
        
    def inASequenceAtom(self, node):
        self.defaultIn(node)

    def outASequenceAtom(self, node):
        self.defaultOut(node)

    def caseASequenceAtom(self, node, *args, **kwargs):
        self.inASequenceAtom(node)
        temp = node.getAtoms()
        temp.reverse()
        for item in temp:
            item.apply(self, *args, **kwargs)
        self.outASequenceAtom(node)
        
    def inAAnyAtom(self, node):
        self.defaultIn(node)

    def outAAnyAtom(self, node):
        self.defaultOut(node)

    def caseAAnyAtom(self, node, *args, **kwargs):
        self.inAAnyAtom(node)
        self.outAAnyAtom(node)
        
    def inAAlternativeAtom(self, node):
        self.defaultIn(node)

    def outAAlternativeAtom(self, node):
        self.defaultOut(node)

    def caseAAlternativeAtom(self, node, *args, **kwargs):
        self.inAAlternativeAtom(node)
        if (node.getRight() != None):
            node.getRight().apply(self, *args, **kwargs)
        if (node.getLeft() != None):
            node.getLeft().apply(self, *args, **kwargs)
        self.outAAlternativeAtom(node)
        
    def inAQuantifiedAtom(self, node):
        self.defaultIn(node)

    def outAQuantifiedAtom(self, node):
        self.defaultOut(node)

    def caseAQuantifiedAtom(self, node, *args, **kwargs):
        self.inAQuantifiedAtom(node)
        if (node.getQuantifier() != None):
            node.getQuantifier().apply(self, *args, **kwargs)
        if (node.getAtom() != None):
            node.getAtom().apply(self, *args, **kwargs)
        self.outAQuantifiedAtom(node)
        
    def inANegativeSetAtom(self, node):
        self.defaultIn(node)

    def outANegativeSetAtom(self, node):
        self.defaultOut(node)

    def caseANegativeSetAtom(self, node, *args, **kwargs):
        self.inANegativeSetAtom(node)
        temp = node.getSymbols()
        temp.reverse()
        for item in temp:
            item.apply(self, *args, **kwargs)
        self.outANegativeSetAtom(node)
        
    def inAPositiveSetAtom(self, node):
        self.defaultIn(node)

    def outAPositiveSetAtom(self, node):
        self.defaultOut(node)

    def caseAPositiveSetAtom(self, node, *args, **kwargs):
        self.inAPositiveSetAtom(node)
        temp = node.getSymbols()
        temp.reverse()
        for item in temp:
            item.apply(self, *args, **kwargs)
        self.outAPositiveSetAtom(node)
        
    def inAZeroOrMoreQuantifier(self, node):
        self.defaultIn(node)

    def outAZeroOrMoreQuantifier(self, node):
        self.defaultOut(node)

    def caseAZeroOrMoreQuantifier(self, node, *args, **kwargs):
        self.inAZeroOrMoreQuantifier(node)
        self.outAZeroOrMoreQuantifier(node)
        
    def inAOneOrMoreQuantifier(self, node):
        self.defaultIn(node)

    def outAOneOrMoreQuantifier(self, node):
        self.defaultOut(node)

    def caseAOneOrMoreQuantifier(self, node, *args, **kwargs):
        self.inAOneOrMoreQuantifier(node)
        self.outAOneOrMoreQuantifier(node)
        
    def inAZeroOrOneQuantifier(self, node):
        self.defaultIn(node)

    def outAZeroOrOneQuantifier(self, node):
        self.defaultOut(node)

    def caseAZeroOrOneQuantifier(self, node, *args, **kwargs):
        self.inAZeroOrOneQuantifier(node)
        self.outAZeroOrOneQuantifier(node)
        


############################# lexer.py ############################################# 

class LexerException(Exception):
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return self.value
        
# lexer states
STATE_NORMAL = 0

accept_tokens = [None] * 17
        
accept_tokens[0] = lambda line, pos: TBlank(None, line, pos)
accept_tokens[1] = lambda line, pos: TChevLeft(line, pos)
accept_tokens[2] = lambda line, pos: TChevRight(line, pos)
accept_tokens[3] = lambda line, pos: TParenLeft(line, pos)
accept_tokens[4] = lambda line, pos: TParenRight(line, pos)
accept_tokens[5] = lambda line, pos: TSqLeft(line, pos)
accept_tokens[6] = lambda line, pos: TSqRight(line, pos)
accept_tokens[7] = lambda line, pos: TBracLeft(line, pos)
accept_tokens[8] = lambda line, pos: TBracRight(line, pos)
accept_tokens[9] = lambda line, pos: TPipe(line, pos)
accept_tokens[10] = lambda line, pos: TStar(line, pos)
accept_tokens[11] = lambda line, pos: TPlus(line, pos)
accept_tokens[12] = lambda line, pos: TComma(line, pos)
accept_tokens[13] = lambda line, pos: THat(line, pos)
accept_tokens[14] = lambda line, pos: TDot(line, pos)
accept_tokens[15] = lambda line, pos: TQuestionMark(line, pos)
accept_tokens[16] = lambda line, pos: TWord(None, line, pos)


lexer_gotoTable = [
                    [
                      [
                        [0, 8, 1],
                        [9, 9, 2],
                        [10, 10, 3],
                        [11, 12, 1],
                        [13, 13, 4],
                        [14, 31, 1],
                        [32, 32, 5],
                        [33, 39, 1],
                        [40, 40, 6],
                        [41, 41, 7],
                        [42, 42, 8],
                        [43, 43, 9],
                        [44, 44, 10],
                        [45, 45, 1],
                        [46, 46, 11],
                        [47, 59, 1],
                        [60, 60, 12],
                        [61, 61, 1],
                        [62, 62, 13],
                        [63, 63, 14],
                        [64, 90, 1],
                        [91, 91, 15],
                        [92, 92, 16],
                        [93, 93, 17],
                        [94, 94, 18],
                        [95, 122, 1],
                        [123, 123, 19],
                        [124, 124, 20],
                        [125, 125, 21],
                        [126, 65535, 1],
                      ],
                      [
                        [0, 8, 1],
                        [11, 12, 1],
                        [14, 31, 1],
                        [33, 39, 1],
                        [44, 45, 1],
                        [47, 59, 1],
                        [61, 61, 1],
                        [64, 90, 1],
                        [92, 92, 16],
                        [95, 122, 1],
                        [126, 65535, 1],
                      ],
                      [
                        [9, 10, -2],
                        [13, 13, 4],
                        [32, 32, 5],
                      ],
                      [
                        [9, 32, -4],
                      ],
                      [
                        [9, 32, -4],
                      ],
                      [
                        [9, 32, -4],
                      ],
                      [
                      ],
                      [
                      ],
                      [
                      ],
                      [
                      ],
                      [
                        [0, 65535, -3],
                      ],
                      [
                      ],
                      [
                      ],
                      [
                      ],
                      [
                      ],
                      [
                      ],
                      [
                        [40, 40, 22],
                        [41, 41, 23],
                        [42, 42, 24],
                        [43, 43, 25],
                        [46, 46, 26],
                        [60, 60, 27],
                        [62, 62, 28],
                        [63, 63, 29],
                        [91, 91, 30],
                        [92, 92, 31],
                        [93, 93, 32],
                        [94, 94, 33],
                        [123, 123, 34],
                        [124, 124, 35],
                        [125, 125, 36],
                      ],
                      [
                      ],
                      [
                      ],
                      [
                      ],
                      [
                      ],
                      [
                      ],
                      [
                        [0, 65535, -3],
                      ],
                      [
                        [0, 65535, -3],
                      ],
                      [
                        [0, 65535, -3],
                      ],
                      [
                        [0, 65535, -3],
                      ],
                      [
                        [0, 65535, -3],
                      ],
                      [
                        [0, 65535, -3],
                      ],
                      [
                        [0, 65535, -3],
                      ],
                      [
                        [0, 65535, -3],
                      ],
                      [
                        [0, 65535, -3],
                      ],
                      [
                        [0, 65535, -3],
                      ],
                      [
                        [0, 65535, -3],
                      ],
                      [
                        [0, 65535, -3],
                      ],
                      [
                        [0, 65535, -3],
                      ],
                      [
                        [0, 65535, -3],
                      ],
                      [
                        [0, 65535, -3],
                      ],
                    ],
                  ] 
                
accept_table = [
                 [
                   -1, 16, 0, 0, 0, 0, 3, 4, 10, 11, 12, 14, 1, 2, 15, 5, -1, 6, 13, 7, 9, 8, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
                 ],
               ]
             
class Lexer(object):
    def __init__(self, source):
        if isinstance(source, str):
            self.reader = PushbackReader(file(source, "r"))
        else:
            self.reader = PushbackReader(source)

        self.token = None
        self.state = STATE_NORMAL
        self.line = 0
        self.pos = 0
        self.cr = False
        self.eof = False
        self.text = StringBuffer()

    def filter(self):
        pass

    def peek(self):
        while(self.token == None):
            self.token = self.getToken()
            self.filter()
        return self.token

    def next(self):
        while (self.token == None):
            self.token = self.getToken()
            self.filter()

        result = self.token
        self.token = None
        return result

    def getToken(self):
        dfa_state = 0

        start_pos = self.pos
        start_line = self.line

        accept_state = -1
        accept_token = -1
        accept_length = -1
        accept_pos = -1
        accept_line = -1
        gotoTable = lexer_gotoTable[self.state]
        accept = accept_table[self.state]
        text = self.text
        text.clear()

        while 1:
            c = self.getChar()

            if(c != -1):
                if (c == 10):
                    if(self.cr):
                        self.cr = False
                    else:
                        self.line = self.line + 1
                        self.pos = 0
                elif (c == 13):
                    self.line = self.line + 1
                    self.pos = 0
                    self.cr = True
                else:
                    self.pos = self.pos + 1
                    self.cr = False

                text.append(chr(c))
                
                while 1:
                    if (dfa_state < -1):
                        oldState = (-2 -dfa_state)
                    else:
                        oldState = dfa_state

                    dfa_state = -1

                    tmp1 =  gotoTable[oldState]
                    low = 0
                    high = len(tmp1) - 1

                    while (low <= high):
                        middle = (low + high) // 2
                        tmp2 = tmp1[middle]

                        if(c < tmp2[0]):
                            high = middle - 1
                        elif (c > tmp2[1]):
                            low = middle + 1
                        else:
                            dfa_state = tmp2[2]
                            break
                    if (dfa_state >= -1):
                        break
            else:
                dfa_state = -1

            if (dfa_state >= 0):
                if (accept[dfa_state] != -1):
                    accept_state = dfa_state
                    accept_token = accept[dfa_state]
                    accept_length = len(text)
                    accept_pos = self.pos
                    accept_line = self.line
            else:
                if (accept_state != -1):
                    if (accept_token >= 0 and accept_token <= 16):
                        token = accept_tokens[accept_token](start_line + 1, start_pos + 1)
                        if token.getText() == None:
                            token.setText(self.getText(accept_length))
                        
                        self.pushBack(accept_length)
                        self.pos = accept_pos
                        self.line = accept_line
                      
                        return token
                else:
                    if (len(text) > 0):
                        raise LexerException("[" + str(start_line + 1) + "," + str(start_pos + 1) + "]" +" Unknown token: " + str(text))
                    else:
                        return EOF(start_line + 1, start_pos + 1)

    def getChar(self):
        if (self.eof):
            return -1
        c = self.reader.read()
        
        if (c == ""):
            result = -1
        else:
            result = ord(c)

        if(result == -1):
            self.eof = True

        return result

    def pushBack(self, acceptLength):
        text = self.text
        length = len(text)
        for i in range(length - 1, acceptLength - 1, -1):
            self.eof = False
            self.reader.unread(text.charAt(i))

    def unread(self, token):
        text = token.getText()
        length = len(text)

        for i in range(length-1, -1, -1):
            self.eof = False
            self.reader.unread(text[i])

        self.pos = token.getPos() - 1
        self.line = token.getLine() - 1

    def getText(self, acceptLength):
        sb = StringBuffer()
        text = self.text
        for i in range(acceptLength):
            sb.append(text.charAt(i))

        return str(sb)

############################# parser.py #############################################

class ParserException(Exception):
    def __init__(self, token, value):
        self.value = value
        self.token = token

    def getToken(self):
        return self.token

    def __str__(self):
        return self.value
        
class State(object):
    def __init__(self, state, nodes):
        self.state = state
        self.nodes = nodes

# parser actions
ACTION_SHIFT = 0
ACTION_REDUCE = 1
ACTION_ACCEPT = 2
ACTION_ERROR = 3
        
def new0(self):
    nodeList = list()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    listNode5 = list()
    listNode4 = nodeArrayList3[0]
    if (listNode4 != None):
        listNode5.extend(listNode4)
    patomNode3 = ASequenceAtom(listNode5)
    pqueryNode1 = AQuery(None,patomNode3,None)
    nodeList.append(pqueryNode1)
    return nodeList, 0

def new1(self):
    nodeList = list()
    nodeArrayList6 = self.pop()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    listNode4 = list()
    listNode3 = nodeArrayList2[0]
    if (listNode3 != None):
        listNode4.extend(listNode3)
    patomNode2 = ASequenceAtom(listNode4)
    listNode7 = list()
    listNode6 = nodeArrayList4[0]
    if (listNode6 != None):
        listNode7.extend(listNode6)
    patomNode5 = ASequenceAtom(listNode7)
    pqueryNode1 = AQuery(patomNode2,patomNode5,None)
    nodeList.append(pqueryNode1)
    return nodeList, 0

def new2(self):
    nodeList = list()
    nodeArrayList6 = self.pop()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    listNode5 = list()
    listNode4 = nodeArrayList3[0]
    if (listNode4 != None):
        listNode5.extend(listNode4)
    patomNode3 = ASequenceAtom(listNode5)
    listNode8 = list()
    listNode7 = nodeArrayList5[0]
    if (listNode7 != None):
        listNode8.extend(listNode7)
    patomNode6 = ASequenceAtom(listNode8)
    pqueryNode1 = AQuery(None,patomNode3,patomNode6)
    nodeList.append(pqueryNode1)
    return nodeList, 0

def new3(self):
    nodeList = list()
    nodeArrayList7 = self.pop()
    nodeArrayList6 = self.pop()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    listNode4 = list()
    listNode3 = nodeArrayList2[0]
    if (listNode3 != None):
        listNode4.extend(listNode3)
    patomNode2 = ASequenceAtom(listNode4)
    listNode7 = list()
    listNode6 = nodeArrayList4[0]
    if (listNode6 != None):
        listNode7.extend(listNode6)
    patomNode5 = ASequenceAtom(listNode7)
    listNode10 = list()
    listNode9 = nodeArrayList6[0]
    if (listNode9 != None):
        listNode10.extend(listNode9)
    patomNode8 = ASequenceAtom(listNode10)
    pqueryNode1 = AQuery(patomNode2,patomNode5,patomNode8)
    nodeList.append(pqueryNode1)
    return nodeList, 0

def new4(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    patomNode1 = nodeArrayList1[0]
    nodeList.append(patomNode1)
    return nodeList, 1

def new5(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    patomNode1 = nodeArrayList1[0]
    nodeList.append(patomNode1)
    return nodeList, 1

def new6(self):
    nodeList = list()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    patomNode2 = nodeArrayList1[0]
    patomNode3 = nodeArrayList3[0]
    patomNode1 = AAlternativeAtom(patomNode2,patomNode3)
    nodeList.append(patomNode1)
    return nodeList, 2

def new7(self):
    nodeList = list()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    patomNode2 = nodeArrayList1[0]
    pquantifierNode3 = AZeroOrMoreQuantifier()
    patomNode1 = AQuantifiedAtom(patomNode2,pquantifierNode3)
    nodeList.append(patomNode1)
    return nodeList, 3

def new8(self):
    nodeList = list()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    patomNode2 = nodeArrayList1[0]
    pquantifierNode3 = AOneOrMoreQuantifier()
    patomNode1 = AQuantifiedAtom(patomNode2,pquantifierNode3)
    nodeList.append(patomNode1)
    return nodeList, 3

def new9(self):
    nodeList = list()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    patomNode2 = nodeArrayList1[0]
    pquantifierNode3 = AZeroOrOneQuantifier()
    patomNode1 = AQuantifiedAtom(patomNode2,pquantifierNode3)
    nodeList.append(patomNode1)
    return nodeList, 3

def new10(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    patomNode1 = nodeArrayList1[0]
    nodeList.append(patomNode1)
    return nodeList, 3

def new11(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    patomNode1 = nodeArrayList1[0]
    nodeList.append(patomNode1)
    return nodeList, 4

def new12(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    psymbolNode2 = nodeArrayList1[0]
    patomNode1 = ASimpleAtom(psymbolNode2)
    nodeList.append(patomNode1)
    return nodeList, 4

def new13(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    patomNode1 = nodeArrayList1[0]
    nodeList.append(patomNode1)
    return nodeList, 4

def new14(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    patomNode1 = nodeArrayList1[0]
    nodeList.append(patomNode1)
    return nodeList, 4

def new15(self):
    nodeList = list()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    listNode3 = list()
    listNode2 = nodeArrayList2[0]
    if (listNode2 != None):
        listNode3.extend(listNode2)
    patomNode1 = ASequenceAtom(listNode3)
    nodeList.append(patomNode1)
    return nodeList, 5

def new16(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    psymboltypeNode2 = nodeArrayList1[0]
    psymbolNode1 = ASimpleSymbol(psymboltypeNode2)
    nodeList.append(psymbolNode1)
    return nodeList, 6

def new17(self):
    nodeList = list()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    psymbolNode1 = ATupleSymbol(None,None,None,None)
    nodeList.append(psymbolNode1)
    return nodeList, 6

def new18(self):
    nodeList = list()
    nodeArrayList6 = self.pop()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    psymboltypeNode2 = nodeArrayList2[0]
    psymbolNode1 = ATupleSymbol(psymboltypeNode2,None,None,None)
    nodeList.append(psymbolNode1)
    return nodeList, 6

def new19(self):
    nodeList = list()
    nodeArrayList6 = self.pop()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    psymboltypeNode3 = nodeArrayList3[0]
    psymbolNode1 = ATupleSymbol(None,psymboltypeNode3,None,None)
    nodeList.append(psymbolNode1)
    return nodeList, 6

def new20(self):
    nodeList = list()
    nodeArrayList7 = self.pop()
    nodeArrayList6 = self.pop()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    psymboltypeNode2 = nodeArrayList2[0]
    psymboltypeNode3 = nodeArrayList4[0]
    psymbolNode1 = ATupleSymbol(psymboltypeNode2,psymboltypeNode3,None,None)
    nodeList.append(psymbolNode1)
    return nodeList, 6

def new21(self):
    nodeList = list()
    nodeArrayList6 = self.pop()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    psymboltypeNode4 = nodeArrayList4[0]
    psymbolNode1 = ATupleSymbol(None,None,psymboltypeNode4,None)
    nodeList.append(psymbolNode1)
    return nodeList, 6

def new22(self):
    nodeList = list()
    nodeArrayList7 = self.pop()
    nodeArrayList6 = self.pop()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    psymboltypeNode2 = nodeArrayList2[0]
    psymboltypeNode4 = nodeArrayList5[0]
    psymbolNode1 = ATupleSymbol(psymboltypeNode2,None,psymboltypeNode4,None)
    nodeList.append(psymbolNode1)
    return nodeList, 6

def new23(self):
    nodeList = list()
    nodeArrayList7 = self.pop()
    nodeArrayList6 = self.pop()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    psymboltypeNode3 = nodeArrayList3[0]
    psymboltypeNode4 = nodeArrayList5[0]
    psymbolNode1 = ATupleSymbol(None,psymboltypeNode3,psymboltypeNode4,None)
    nodeList.append(psymbolNode1)
    return nodeList, 6

def new24(self):
    nodeList = list()
    nodeArrayList8 = self.pop()
    nodeArrayList7 = self.pop()
    nodeArrayList6 = self.pop()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    psymboltypeNode2 = nodeArrayList2[0]
    psymboltypeNode3 = nodeArrayList4[0]
    psymboltypeNode4 = nodeArrayList6[0]
    psymbolNode1 = ATupleSymbol(psymboltypeNode2,psymboltypeNode3,psymboltypeNode4,None)
    nodeList.append(psymbolNode1)
    return nodeList, 6

def new25(self):
    nodeList = list()
    nodeArrayList6 = self.pop()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    psymboltypeNode5 = nodeArrayList5[0]
    psymbolNode1 = ATupleSymbol(None,None,None,psymboltypeNode5)
    nodeList.append(psymbolNode1)
    return nodeList, 6

def new26(self):
    nodeList = list()
    nodeArrayList7 = self.pop()
    nodeArrayList6 = self.pop()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    psymboltypeNode2 = nodeArrayList2[0]
    psymboltypeNode5 = nodeArrayList6[0]
    psymbolNode1 = ATupleSymbol(psymboltypeNode2,None,None,psymboltypeNode5)
    nodeList.append(psymbolNode1)
    return nodeList, 6

def new27(self):
    nodeList = list()
    nodeArrayList7 = self.pop()
    nodeArrayList6 = self.pop()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    psymboltypeNode3 = nodeArrayList3[0]
    psymboltypeNode5 = nodeArrayList6[0]
    psymbolNode1 = ATupleSymbol(None,psymboltypeNode3,None,psymboltypeNode5)
    nodeList.append(psymbolNode1)
    return nodeList, 6

def new28(self):
    nodeList = list()
    nodeArrayList8 = self.pop()
    nodeArrayList7 = self.pop()
    nodeArrayList6 = self.pop()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    psymboltypeNode2 = nodeArrayList2[0]
    psymboltypeNode3 = nodeArrayList4[0]
    psymboltypeNode5 = nodeArrayList7[0]
    psymbolNode1 = ATupleSymbol(psymboltypeNode2,psymboltypeNode3,None,psymboltypeNode5)
    nodeList.append(psymbolNode1)
    return nodeList, 6

def new29(self):
    nodeList = list()
    nodeArrayList7 = self.pop()
    nodeArrayList6 = self.pop()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    psymboltypeNode4 = nodeArrayList4[0]
    psymboltypeNode5 = nodeArrayList6[0]
    psymbolNode1 = ATupleSymbol(None,None,psymboltypeNode4,psymboltypeNode5)
    nodeList.append(psymbolNode1)
    return nodeList, 6

def new30(self):
    nodeList = list()
    nodeArrayList8 = self.pop()
    nodeArrayList7 = self.pop()
    nodeArrayList6 = self.pop()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    psymboltypeNode2 = nodeArrayList2[0]
    psymboltypeNode4 = nodeArrayList5[0]
    psymboltypeNode5 = nodeArrayList7[0]
    psymbolNode1 = ATupleSymbol(psymboltypeNode2,None,psymboltypeNode4,psymboltypeNode5)
    nodeList.append(psymbolNode1)
    return nodeList, 6

def new31(self):
    nodeList = list()
    nodeArrayList8 = self.pop()
    nodeArrayList7 = self.pop()
    nodeArrayList6 = self.pop()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    psymboltypeNode3 = nodeArrayList3[0]
    psymboltypeNode4 = nodeArrayList5[0]
    psymboltypeNode5 = nodeArrayList7[0]
    psymbolNode1 = ATupleSymbol(None,psymboltypeNode3,psymboltypeNode4,psymboltypeNode5)
    nodeList.append(psymbolNode1)
    return nodeList, 6

def new32(self):
    nodeList = list()
    nodeArrayList9 = self.pop()
    nodeArrayList8 = self.pop()
    nodeArrayList7 = self.pop()
    nodeArrayList6 = self.pop()
    nodeArrayList5 = self.pop()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    psymboltypeNode2 = nodeArrayList2[0]
    psymboltypeNode3 = nodeArrayList4[0]
    psymboltypeNode4 = nodeArrayList6[0]
    psymboltypeNode5 = nodeArrayList8[0]
    psymbolNode1 = ATupleSymbol(psymboltypeNode2,psymboltypeNode3,psymboltypeNode4,psymboltypeNode5)
    nodeList.append(psymbolNode1)
    return nodeList, 6

def new33(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    twordNode2 = nodeArrayList1[0]
    psymboltypeNode1 = ALiteralSymbolType(twordNode2)
    nodeList.append(psymboltypeNode1)
    return nodeList, 7

def new34(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    patomNode1 = AAnyAtom()
    nodeList.append(patomNode1)
    return nodeList, 8

def new35(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    patomNode1 = nodeArrayList1[0]
    nodeList.append(patomNode1)
    return nodeList, 9

def new36(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    patomNode1 = nodeArrayList1[0]
    nodeList.append(patomNode1)
    return nodeList, 9

def new37(self):
    nodeList = list()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    listNode3 = list()
    listNode2 = nodeArrayList2[0]
    if (listNode2 != None):
        listNode3.extend(listNode2)
    patomNode1 = APositiveSetAtom(listNode3)
    nodeList.append(patomNode1)
    return nodeList, 10

def new38(self):
    nodeList = list()
    nodeArrayList4 = self.pop()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    listNode3 = list()
    listNode2 = nodeArrayList3[0]
    if (listNode2 != None):
        listNode3.extend(listNode2)
    patomNode1 = ANegativeSetAtom(listNode3)
    nodeList.append(patomNode1)
    return nodeList, 11

def new39(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    listNode2 = list()
    listNode1 = nodeArrayList1[0]
    if (listNode1 != None):
        listNode2.extend(listNode1)
    nodeList.append(listNode2)
    return nodeList, 12

def new40(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    listNode2 = list()
    patomNode1 = nodeArrayList1[0]
    if (patomNode1 != None):
        listNode2.append(patomNode1)
    nodeList.append(listNode2)
    return nodeList, 13

def new41(self):
    nodeList = list()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    listNode3 = list()
    listNode1 = nodeArrayList1[0]
    patomNode2 = nodeArrayList2[0]
    if (listNode1 != None):
        listNode3.extend(listNode1)
    if (patomNode2 != None):
        listNode3.append(patomNode2)
    nodeList.append(listNode3)
    return nodeList, 13

def new42(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    listNode2 = list()
    psymbolNode1 = nodeArrayList1[0]
    if (psymbolNode1 != None):
        listNode2.append(psymbolNode1)
    nodeList.append(listNode2)
    return nodeList, 14

def new43(self):
    nodeList = list()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    listNode3 = list()
    listNode1 = nodeArrayList1[0]
    psymbolNode2 = nodeArrayList2[0]
    if (listNode1 != None):
        listNode3.extend(listNode1)
    if (psymbolNode2 != None):
        listNode3.append(psymbolNode2)
    nodeList.append(listNode3)
    return nodeList, 14

newnode = [
  new0,
  new1,
  new2,
  new3,
  new4,
  new5,
  new6,
  new7,
  new8,
  new9,
  new10,
  new11,
  new12,
  new13,
  new14,
  new15,
  new16,
  new17,
  new18,
  new19,
  new20,
  new21,
  new22,
  new23,
  new24,
  new25,
  new26,
  new27,
  new28,
  new29,
  new30,
  new31,
  new32,
  new33,
  new34,
  new35,
  new36,
  new37,
  new38,
  new39,
  new40,
  new41,
  new42,
  new43
]

actionTable = [
                [
                  [-1, 3, 0],
                  [0, 0, 1],
                ],
                [
                  [-1, 3, 1],
                  [0, 0, 3],
                  [1, 0, 4],
                  [2, 0, 5],
                  [4, 0, 6],
                  [13, 0, 7],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 2],
                  [16, 2, -1],
                ],
                [
                  [-1, 3, 3],
                  [11, 0, 21],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 4],
                  [0, 0, 3],
                  [2, 0, 5],
                  [4, 0, 6],
                  [13, 0, 7],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 5],
                  [0, 0, 3],
                  [2, 0, 5],
                  [4, 0, 6],
                  [13, 0, 7],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 6],
                  [0, 0, 3],
                  [12, 0, 25],
                  [15, 0, 8],
                ],
                [
                  [-1, 1, 34],
                ],
                [
                  [-1, 1, 33],
                ],
                [
                  [-1, 1, 40],
                  [8, 0, 29],
                ],
                [
                  [-1, 1, 5],
                ],
                [
                  [-1, 1, 4],
                ],
                [
                  [-1, 1, 10],
                  [9, 0, 30],
                  [10, 0, 31],
                  [14, 0, 32],
                ],
                [
                  [-1, 1, 11],
                ],
                [
                  [-1, 1, 12],
                ],
                [
                  [-1, 1, 16],
                ],
                [
                  [-1, 1, 13],
                ],
                [
                  [-1, 1, 14],
                ],
                [
                  [-1, 1, 35],
                ],
                [
                  [-1, 1, 36],
                ],
                [
                  [-1, 3, 20],
                  [0, 0, 3],
                  [1, 0, 33],
                  [2, 0, 5],
                  [4, 0, 6],
                  [13, 0, 7],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 21],
                  [11, 0, 35],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 22],
                  [11, 0, 37],
                ],
                [
                  [-1, 3, 23],
                  [0, 0, 38],
                  [2, 0, 5],
                  [4, 0, 6],
                  [13, 0, 7],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 24],
                  [0, 0, 3],
                  [2, 0, 5],
                  [3, 0, 39],
                  [4, 0, 6],
                  [13, 0, 7],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 25],
                  [0, 0, 3],
                  [15, 0, 8],
                ],
                [
                  [-1, 1, 42],
                ],
                [
                  [-1, 3, 27],
                  [5, 0, 41],
                ],
                [
                  [-1, 1, 39],
                  [0, 0, 3],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 29],
                  [0, 0, 3],
                  [2, 0, 5],
                  [4, 0, 6],
                  [13, 0, 7],
                  [15, 0, 8],
                ],
                [
                  [-1, 1, 7],
                ],
                [
                  [-1, 1, 8],
                ],
                [
                  [-1, 1, 9],
                ],
                [
                  [-1, 3, 33],
                  [0, 0, 3],
                  [2, 0, 5],
                  [4, 0, 6],
                  [13, 0, 7],
                  [15, 0, 8],
                ],
                [
                  [-1, 1, 41],
                  [8, 0, 29],
                ],
                [
                  [-1, 3, 35],
                  [11, 0, 45],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 36],
                  [11, 0, 47],
                ],
                [
                  [-1, 3, 37],
                  [11, 0, 48],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 38],
                  [0, 0, 3],
                  [1, 0, 50],
                  [2, 0, 5],
                  [4, 0, 6],
                  [11, 0, 21],
                  [13, 0, 7],
                  [15, 0, 8],
                ],
                [
                  [-1, 1, 15],
                ],
                [
                  [-1, 3, 40],
                  [5, 0, 53],
                ],
                [
                  [-1, 1, 37],
                ],
                [
                  [-1, 1, 43],
                ],
                [
                  [-1, 1, 6],
                ],
                [
                  [-1, 3, 44],
                  [0, 0, 54],
                  [2, 0, 5],
                  [4, 0, 6],
                  [13, 0, 7],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 45],
                  [1, 0, 55],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 46],
                  [11, 0, 57],
                ],
                [
                  [-1, 3, 47],
                  [11, 0, 58],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 48],
                  [11, 0, 60],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 49],
                  [11, 0, 62],
                ],
                [
                  [-1, 1, 0],
                ],
                [
                  [-1, 1, 16],
                  [11, 0, 37],
                ],
                [
                  [-1, 3, 52],
                  [0, 0, 3],
                  [1, 0, 63],
                  [2, 0, 5],
                  [4, 0, 6],
                  [13, 0, 7],
                  [15, 0, 8],
                ],
                [
                  [-1, 1, 38],
                ],
                [
                  [-1, 3, 54],
                  [0, 0, 3],
                  [1, 0, 64],
                  [2, 0, 5],
                  [4, 0, 6],
                  [11, 0, 21],
                  [13, 0, 7],
                  [15, 0, 8],
                ],
                [
                  [-1, 1, 17],
                ],
                [
                  [-1, 3, 56],
                  [1, 0, 66],
                ],
                [
                  [-1, 3, 57],
                  [1, 0, 67],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 58],
                  [1, 0, 69],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 59],
                  [11, 0, 71],
                ],
                [
                  [-1, 3, 60],
                  [1, 0, 72],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 61],
                  [11, 0, 74],
                ],
                [
                  [-1, 3, 62],
                  [11, 0, 75],
                  [15, 0, 8],
                ],
                [
                  [-1, 1, 2],
                ],
                [
                  [-1, 1, 1],
                ],
                [
                  [-1, 3, 65],
                  [0, 0, 3],
                  [1, 0, 77],
                  [2, 0, 5],
                  [4, 0, 6],
                  [13, 0, 7],
                  [15, 0, 8],
                ],
                [
                  [-1, 1, 25],
                ],
                [
                  [-1, 1, 21],
                ],
                [
                  [-1, 3, 68],
                  [1, 0, 78],
                ],
                [
                  [-1, 1, 19],
                ],
                [
                  [-1, 3, 70],
                  [1, 0, 79],
                ],
                [
                  [-1, 3, 71],
                  [1, 0, 80],
                  [15, 0, 8],
                ],
                [
                  [-1, 1, 18],
                ],
                [
                  [-1, 3, 73],
                  [1, 0, 82],
                ],
                [
                  [-1, 3, 74],
                  [1, 0, 83],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 75],
                  [1, 0, 85],
                  [15, 0, 8],
                ],
                [
                  [-1, 3, 76],
                  [11, 0, 87],
                ],
                [
                  [-1, 1, 3],
                ],
                [
                  [-1, 1, 29],
                ],
                [
                  [-1, 1, 27],
                ],
                [
                  [-1, 1, 23],
                ],
                [
                  [-1, 3, 81],
                  [1, 0, 88],
                ],
                [
                  [-1, 1, 26],
                ],
                [
                  [-1, 1, 22],
                ],
                [
                  [-1, 3, 84],
                  [1, 0, 89],
                ],
                [
                  [-1, 1, 20],
                ],
                [
                  [-1, 3, 86],
                  [1, 0, 90],
                ],
                [
                  [-1, 3, 87],
                  [1, 0, 91],
                  [15, 0, 8],
                ],
                [
                  [-1, 1, 31],
                ],
                [
                  [-1, 1, 30],
                ],
                [
                  [-1, 1, 28],
                ],
                [
                  [-1, 1, 24],
                ],
                [
                  [-1, 3, 92],
                  [1, 0, 93],
                ],
                [
                  [-1, 1, 32],
                ],
              ]

parser_gotoTable = [
                     [
                       [-1, 2],
                     ],
                     [
                       [-1, 9],
                       [20, 34],
                       [23, 34],
                       [24, 34],
                       [44, 34],
                       [52, 34],
                       [65, 34],
                     ],
                     [
                       [-1, 10],
                     ],
                     [
                       [-1, 11],
                       [29, 43],
                     ],
                     [
                       [-1, 12],
                     ],
                     [
                       [-1, 13],
                     ],
                     [
                       [-1, 14],
                       [6, 26],
                       [25, 26],
                       [28, 42],
                     ],
                     [
                       [-1, 15],
                       [3, 22],
                       [21, 36],
                       [35, 46],
                       [37, 49],
                       [38, 51],
                       [45, 56],
                       [47, 59],
                       [48, 61],
                       [54, 51],
                       [57, 68],
                       [58, 70],
                       [60, 73],
                       [62, 76],
                       [71, 81],
                       [74, 84],
                       [75, 86],
                       [87, 92],
                     ],
                     [
                       [-1, 16],
                     ],
                     [
                       [-1, 17],
                     ],
                     [
                       [-1, 18],
                     ],
                     [
                       [-1, 19],
                     ],
                     [
                       [-1, 27],
                       [25, 40],
                     ],
                     [
                       [-1, 20],
                       [4, 23],
                       [5, 24],
                       [33, 44],
                       [38, 52],
                       [54, 65],
                     ],
                     [
                       [-1, 28],
                     ],
                   ]
    
errorMessages = [
                  "expecting: '<'",
                  "expecting: '<', '>', '(', '[', '.', word",
                  "expecting: EOF",
                  "expecting: ',', word",
                  "expecting: '<', '(', '[', '.', word",
                  "expecting: '<', '^', word",
                  "expecting: '<', '>', '(', ')', '[', '|', '*', '+', '.', '?', word",
                  "expecting: '<', '>', '(', ')', '[', ']', '|', '*', '+', ',', '.', '?', word",
                  "expecting: '<', '>', '(', ')', '[', '|', '.', word",
                  "expecting: '<', '>', '(', ')', '[', ']', '|', '*', '+', '.', '?', word",
                  "expecting: ','",
                  "expecting: '<', '(', ')', '[', '.', word",
                  "expecting: '<', word",
                  "expecting: '<', ']', word",
                  "expecting: ']'",
                  "expecting: '<', '>', '(', '[', ',', '.', word",
                  "expecting: '>', word",
                  "expecting: '<', '>', '(', '[', '|', '*', '+', ',', '.', '?', word",
                  "expecting: '>'",
                ]
    
errors = [
           0, 1, 2, 3, 4, 4, 5, 6, 7, 8, 8, 8, 6, 6, 6, 9, 6, 6, 6, 6, 1, 3, 10, 4, 11, 12, 13, 14, 13, 4, 8, 8, 8, 4, 8, 3, 10, 3, 15, 6, 14, 6, 13, 8, 4, 16, 10, 3, 3, 10, 2, 17, 1, 6, 15, 9, 18, 16, 16, 10, 16, 10, 3, 2, 2, 1, 9, 9, 18, 9, 18, 16, 9, 18, 16, 16, 10, 2, 9, 9, 9, 18, 9, 9, 18, 9, 18, 16, 9, 9, 9, 9, 18, 9, 
         ]
                                   
class Parser(object):
    def __init__(self, lexer):
        self.lexer = lexer
        self.stack = Stack()
     
    def goTo(self, index):
        state = self.state()
        low = 1
        high = len(parser_gotoTable[index]) - 1
        value = parser_gotoTable[index][0][1]

        while (low <= high):
            middle = (low + high) // 2

            if (state < parser_gotoTable[index][middle][0]):
                high = middle - 1
            elif (state > parser_gotoTable[index][middle][0]):
                low = middle + 1
            else:
                value = parser_gotoTable[index][middle][1]
                break

        return value

    def push(self, numstate, listNode):
        self.stack.push(State(numstate, listNode))

    def state(self):
        return self.stack.peek().state

    def pop(self):
        return self.stack.pop().nodes

    def parse(self):
        self.push(0, None)
        lexer = self.lexer
        last_shift = 0
        last_pos = 0
        last_line = 0
        last_token = None
        action = [0,0]
        
        while 1:
            while (lexer.peek().TokenIndex == -1):
                lexer.next()

            token = lexer.peek()
            last_pos = token.getPos()
            last_line = token.getLine()
            last_token = token

            index = token.TokenIndex
            action[0] = actionTable[self.state()][0][1]
            action[1] = actionTable[self.state()][0][2]

            low = 1
            high = len(actionTable[self.state()]) - 1

            while (low <= high):
                middle = (low + high) // 2

                if (index < actionTable[self.state()][middle][0]):
                    high = middle - 1
                elif (index > actionTable[self.state()][middle][0]):
                    low = middle + 1
                else:
                    action[0] = actionTable[self.state()][middle][1]
                    action[1] = actionTable[self.state()][middle][2]
                    break

            if (action[0] == ACTION_SHIFT):
                nodeList = list()
                nodeList.append(lexer.next())
                self.push(action[1], nodeList)
                last_shift = action[1]
            elif (action[0] == ACTION_REDUCE):
                if (action[1] >= 0 and action[1] <= 43):
                    nodeList, leftside = newnode[action[1]](self)
                    self.push(self.goTo(leftside), nodeList)
            elif (action[0] == ACTION_ACCEPT):
                node2 = lexer.next()
                node1 = self.pop()[0]
                node = Start(node1, node2)
                return node
            elif (action[0] == ACTION_ERROR):
                raise ParserException(last_token, "[" + str(last_line) + "," + str(last_pos) + "] " + errorMessages[errors[action[1]]])
    
    def unescape (self, s):
        _out_ = StringBuffer()
      
        for i in range(len(s)):
            c = s[i]

            if (c == '\\'):
                if ((i + 1) < len(s)):
                    i += 1
                    if (s[i] == 'n'):
                        _out_.append ("\n")
                    elif (s[i] == 'r'):
                        _out_.append("\r")
                    elif (s[i] == '"'):
                        _out_.append ("\"");
                    elif (s[i] == '\\'):
                        _out_.append ("\\");
                    elif (s[i] == '0'):
                        if (s[i:].startswith("000")):
                            _out_.append("\000")
                            i += 2
                        else:
                            _out_.append ("\\")
                            _out_.append(s[i])
                    elif (s[i] == 'u'):
                        hstr = s[i+1:(i + 5)]
                    
                        if (len(hstr) == 4):
                            try:
                                _out_.append(unichr(int(hstr, 16)))
                                i += 5
                            except ValueError:
                                _out_.append("\\")
                                _out_.append(s[i])
                        else:
                            _out_.append("\\")
                            _out_.append(s[i])
                    else:
                        _out_.append("\\")
                        _out_.append(s[i])
                else:
                    _out_.append(c)
            else:
                _out_.append(c)
              
        return str(_out_)


